/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface StateConnectorInterface extends ethers.utils.Interface {
  functions: {
    "chains(uint32)": FunctionFragment;
    "commitRevealLowerBound()": FunctionFragment;
    "commitRevealUpperBound()": FunctionFragment;
    "dataAvailabilityPeriodsMined(address,uint256)": FunctionFragment;
    "disprovePaymentFinality(uint32,bytes32,uint64,string)": FunctionFragment;
    "finalisedDataAvailabilityPeriods(bytes32)": FunctionFragment;
    "finalisedPayments(bytes32)": FunctionFragment;
    "getDataAvailabilityPeriodIndexFinality(uint32,uint64)": FunctionFragment;
    "getDataAvailabilityPeriodsMined(address,uint256)": FunctionFragment;
    "getLatestIndex(uint32)": FunctionFragment;
    "getPaymentFinality(uint32,bytes32,bytes32,uint64,bytes32)": FunctionFragment;
    "getRewardPeriod()": FunctionFragment;
    "getTotalDataAvailabilityPeriodsMined(uint256)": FunctionFragment;
    "initialiseChains()": FunctionFragment;
    "initialiseTime()": FunctionFragment;
    "initialised()": FunctionFragment;
    "numChains()": FunctionFragment;
    "proposedDataAvailabilityProofs(address,bytes32)": FunctionFragment;
    "proposedNonPaymentProofs(bytes32,uint64)": FunctionFragment;
    "proposedPaymentProofs(bytes32,uint64)": FunctionFragment;
    "proveDataAvailabilityPeriodFinality(uint32,uint64,bytes32,bytes32)": FunctionFragment;
    "provePaymentFinality(uint32,bytes32,uint64,string)": FunctionFragment;
    "rewardPeriodTimespan()": FunctionFragment;
    "senderBannedUntil(address)": FunctionFragment;
    "totalDataAvailabilityPeriodsMined(uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "chains",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "commitRevealLowerBound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "commitRevealUpperBound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "dataAvailabilityPeriodsMined",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "disprovePaymentFinality",
    values: [BigNumberish, BytesLike, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "finalisedDataAvailabilityPeriods",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "finalisedPayments",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getDataAvailabilityPeriodIndexFinality",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getDataAvailabilityPeriodsMined",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getLatestIndex",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPaymentFinality",
    values: [BigNumberish, BytesLike, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalDataAvailabilityPeriodsMined",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialiseChains",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialiseTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialised",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "numChains", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proposedDataAvailabilityProofs",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "proposedNonPaymentProofs",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proposedPaymentProofs",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "proveDataAvailabilityPeriodFinality",
    values: [BigNumberish, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "provePaymentFinality",
    values: [BigNumberish, BytesLike, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "rewardPeriodTimespan",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "senderBannedUntil",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "totalDataAvailabilityPeriodsMined",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "chains", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "commitRevealLowerBound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "commitRevealUpperBound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "dataAvailabilityPeriodsMined",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disprovePaymentFinality",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalisedDataAvailabilityPeriods",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalisedPayments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDataAvailabilityPeriodIndexFinality",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDataAvailabilityPeriodsMined",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLatestIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPaymentFinality",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalDataAvailabilityPeriodsMined",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initialiseChains",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initialiseTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initialised",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "numChains", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proposedDataAvailabilityProofs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposedNonPaymentProofs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposedPaymentProofs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proveDataAvailabilityPeriodFinality",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "provePaymentFinality",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardPeriodTimespan",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "senderBannedUntil",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalDataAvailabilityPeriodsMined",
    data: BytesLike
  ): Result;

  events: {
    "DataAvailabilityPeriodFinalityProved(uint32,uint64,uint8,address)": EventFragment;
    "PaymentFinalityDisproved(uint32,uint64,string,bytes32,address)": EventFragment;
    "PaymentFinalityProved(uint32,uint64,string,bytes32,address)": EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: "DataAvailabilityPeriodFinalityProved"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentFinalityDisproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentFinalityProved"): EventFragment;
}

export class StateConnector extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: StateConnectorInterface;

  functions: {
    chains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        number,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        exists: boolean;
        genesisLedger: BigNumber;
        ledgerHistorySize: BigNumber;
        dataAvailabilityPeriodLength: number;
        numConfirmations: number;
        finalisedDataAvailabilityPeriodIndex: BigNumber;
        finalisedLedgerIndex: BigNumber;
        finalisedTimestamp: BigNumber;
        timeDiffExpected: BigNumber;
        timeDiffAvg: BigNumber;
      }
    >;

    commitRevealLowerBound(overrides?: CallOverrides): Promise<[BigNumber]>;

    commitRevealUpperBound(overrides?: CallOverrides): Promise<[BigNumber]>;

    dataAvailabilityPeriodsMined(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    disprovePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    finalisedDataAvailabilityPeriods(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    finalisedPayments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    getDataAvailabilityPeriodIndexFinality(
      chainId: BigNumberish,
      dataAvailabilityPeriodIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { finality: boolean }>;

    getDataAvailabilityPeriodsMined(
      miner: string,
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { numMined: BigNumber }>;

    getLatestIndex(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, number, BigNumber, BigNumber, BigNumber] & {
        genesisLedger: BigNumber;
        finalisedDataAvailabilityPeriodIndex: BigNumber;
        dataAvailabilityPeriodLength: number;
        finalisedLedgerIndex: BigNumber;
        finalisedTimestamp: BigNumber;
        timeDiffAvg: BigNumber;
      }
    >;

    getPaymentFinality(
      chainId: BigNumberish,
      txId: BytesLike,
      destinationHash: BytesLike,
      amount: BigNumberish,
      currencyHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        ledger: BigNumber;
        indexSearchRegion: BigNumber;
        finality: boolean;
      }
    >;

    getRewardPeriod(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardSchedule: BigNumber }>;

    getTotalDataAvailabilityPeriodsMined(
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { numMined: BigNumber }>;

    initialiseChains(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialiseTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    initialised(overrides?: CallOverrides): Promise<[boolean]>;

    numChains(overrides?: CallOverrides): Promise<[number]>;

    proposedDataAvailabilityProofs(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    proposedNonPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    proposedPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    proveDataAvailabilityPeriodFinality(
      chainId: BigNumberish,
      ledger: BigNumberish,
      dataAvailabilityPeriodHash: BytesLike,
      chainTipHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    provePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rewardPeriodTimespan(overrides?: CallOverrides): Promise<[BigNumber]>;

    senderBannedUntil(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    totalDataAvailabilityPeriodsMined(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  chains(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      BigNumber,
      BigNumber,
      number,
      number,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      exists: boolean;
      genesisLedger: BigNumber;
      ledgerHistorySize: BigNumber;
      dataAvailabilityPeriodLength: number;
      numConfirmations: number;
      finalisedDataAvailabilityPeriodIndex: BigNumber;
      finalisedLedgerIndex: BigNumber;
      finalisedTimestamp: BigNumber;
      timeDiffExpected: BigNumber;
      timeDiffAvg: BigNumber;
    }
  >;

  commitRevealLowerBound(overrides?: CallOverrides): Promise<BigNumber>;

  commitRevealUpperBound(overrides?: CallOverrides): Promise<BigNumber>;

  dataAvailabilityPeriodsMined(
    arg0: string,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  disprovePaymentFinality(
    chainId: BigNumberish,
    paymentHash: BytesLike,
    ledger: BigNumberish,
    txId: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  finalisedDataAvailabilityPeriods(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      BigNumber,
      boolean,
      string
    ] & {
      exists: boolean;
      dataAvailabilityPeriodHash: string;
      commitHash: string;
      commitTime: BigNumber;
      permittedRevealTime: BigNumber;
      revealHash: string;
      index: BigNumber;
      indexSearchRegion: BigNumber;
      proven: boolean;
      provenBy: string;
    }
  >;

  finalisedPayments(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      BigNumber,
      boolean,
      string
    ] & {
      exists: boolean;
      dataAvailabilityPeriodHash: string;
      commitHash: string;
      commitTime: BigNumber;
      permittedRevealTime: BigNumber;
      revealHash: string;
      index: BigNumber;
      indexSearchRegion: BigNumber;
      proven: boolean;
      provenBy: string;
    }
  >;

  getDataAvailabilityPeriodIndexFinality(
    chainId: BigNumberish,
    dataAvailabilityPeriodIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getDataAvailabilityPeriodsMined(
    miner: string,
    rewardSchedule: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getLatestIndex(
    chainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, number, BigNumber, BigNumber, BigNumber] & {
      genesisLedger: BigNumber;
      finalisedDataAvailabilityPeriodIndex: BigNumber;
      dataAvailabilityPeriodLength: number;
      finalisedLedgerIndex: BigNumber;
      finalisedTimestamp: BigNumber;
      timeDiffAvg: BigNumber;
    }
  >;

  getPaymentFinality(
    chainId: BigNumberish,
    txId: BytesLike,
    destinationHash: BytesLike,
    amount: BigNumberish,
    currencyHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & {
      ledger: BigNumber;
      indexSearchRegion: BigNumber;
      finality: boolean;
    }
  >;

  getRewardPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  getTotalDataAvailabilityPeriodsMined(
    rewardSchedule: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  initialiseChains(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialiseTime(overrides?: CallOverrides): Promise<BigNumber>;

  initialised(overrides?: CallOverrides): Promise<boolean>;

  numChains(overrides?: CallOverrides): Promise<number>;

  proposedDataAvailabilityProofs(
    arg0: string,
    arg1: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      BigNumber,
      boolean,
      string
    ] & {
      exists: boolean;
      dataAvailabilityPeriodHash: string;
      commitHash: string;
      commitTime: BigNumber;
      permittedRevealTime: BigNumber;
      revealHash: string;
      index: BigNumber;
      indexSearchRegion: BigNumber;
      proven: boolean;
      provenBy: string;
    }
  >;

  proposedNonPaymentProofs(
    arg0: BytesLike,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      BigNumber,
      boolean,
      string
    ] & {
      exists: boolean;
      dataAvailabilityPeriodHash: string;
      commitHash: string;
      commitTime: BigNumber;
      permittedRevealTime: BigNumber;
      revealHash: string;
      index: BigNumber;
      indexSearchRegion: BigNumber;
      proven: boolean;
      provenBy: string;
    }
  >;

  proposedPaymentProofs(
    arg0: BytesLike,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      BigNumber,
      BigNumber,
      boolean,
      string
    ] & {
      exists: boolean;
      dataAvailabilityPeriodHash: string;
      commitHash: string;
      commitTime: BigNumber;
      permittedRevealTime: BigNumber;
      revealHash: string;
      index: BigNumber;
      indexSearchRegion: BigNumber;
      proven: boolean;
      provenBy: string;
    }
  >;

  proveDataAvailabilityPeriodFinality(
    chainId: BigNumberish,
    ledger: BigNumberish,
    dataAvailabilityPeriodHash: BytesLike,
    chainTipHash: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  provePaymentFinality(
    chainId: BigNumberish,
    paymentHash: BytesLike,
    ledger: BigNumberish,
    txId: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rewardPeriodTimespan(overrides?: CallOverrides): Promise<BigNumber>;

  senderBannedUntil(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalDataAvailabilityPeriodsMined(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    chains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        BigNumber,
        BigNumber,
        number,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        exists: boolean;
        genesisLedger: BigNumber;
        ledgerHistorySize: BigNumber;
        dataAvailabilityPeriodLength: number;
        numConfirmations: number;
        finalisedDataAvailabilityPeriodIndex: BigNumber;
        finalisedLedgerIndex: BigNumber;
        finalisedTimestamp: BigNumber;
        timeDiffExpected: BigNumber;
        timeDiffAvg: BigNumber;
      }
    >;

    commitRevealLowerBound(overrides?: CallOverrides): Promise<BigNumber>;

    commitRevealUpperBound(overrides?: CallOverrides): Promise<BigNumber>;

    dataAvailabilityPeriodsMined(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    disprovePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, string, string] & {
        _chainId: number;
        _ledger: BigNumber;
        _finalisedLedgerIndex: BigNumber;
        _paymentHash: string;
        _txId: string;
      }
    >;

    finalisedDataAvailabilityPeriods(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    finalisedPayments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    getDataAvailabilityPeriodIndexFinality(
      chainId: BigNumberish,
      dataAvailabilityPeriodIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getDataAvailabilityPeriodsMined(
      miner: string,
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLatestIndex(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, number, BigNumber, BigNumber, BigNumber] & {
        genesisLedger: BigNumber;
        finalisedDataAvailabilityPeriodIndex: BigNumber;
        dataAvailabilityPeriodLength: number;
        finalisedLedgerIndex: BigNumber;
        finalisedTimestamp: BigNumber;
        timeDiffAvg: BigNumber;
      }
    >;

    getPaymentFinality(
      chainId: BigNumberish,
      txId: BytesLike,
      destinationHash: BytesLike,
      amount: BigNumberish,
      currencyHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        ledger: BigNumber;
        indexSearchRegion: BigNumber;
        finality: boolean;
      }
    >;

    getRewardPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalDataAvailabilityPeriodsMined(
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialiseChains(overrides?: CallOverrides): Promise<boolean>;

    initialiseTime(overrides?: CallOverrides): Promise<BigNumber>;

    initialised(overrides?: CallOverrides): Promise<boolean>;

    numChains(overrides?: CallOverrides): Promise<number>;

    proposedDataAvailabilityProofs(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    proposedNonPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    proposedPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        BigNumber,
        BigNumber,
        boolean,
        string
      ] & {
        exists: boolean;
        dataAvailabilityPeriodHash: string;
        commitHash: string;
        commitTime: BigNumber;
        permittedRevealTime: BigNumber;
        revealHash: string;
        index: BigNumber;
        indexSearchRegion: BigNumber;
        proven: boolean;
        provenBy: string;
      }
    >;

    proveDataAvailabilityPeriodFinality(
      chainId: BigNumberish,
      ledger: BigNumberish,
      dataAvailabilityPeriodHash: BytesLike,
      chainTipHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, number, string] & {
        _chainId: number;
        _ledger: BigNumber;
        _numConfirmations: number;
        _dataAvailabilityPeriodHash: string;
      }
    >;

    provePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, string, string] & {
        _chainId: number;
        _ledger: BigNumber;
        _finalisedLedgerIndex: BigNumber;
        _paymentHash: string;
        _txId: string;
      }
    >;

    rewardPeriodTimespan(overrides?: CallOverrides): Promise<BigNumber>;

    senderBannedUntil(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalDataAvailabilityPeriodsMined(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    DataAvailabilityPeriodFinalityProved(
      chainId?: null,
      ledger?: null,
      finType?: null,
      sender?: null
    ): TypedEventFilter<
      [number, BigNumber, number, string],
      { chainId: number; ledger: BigNumber; finType: number; sender: string }
    >;

    PaymentFinalityDisproved(
      chainId?: null,
      ledger?: null,
      txId?: null,
      paymentHash?: null,
      sender?: null
    ): TypedEventFilter<
      [number, BigNumber, string, string, string],
      {
        chainId: number;
        ledger: BigNumber;
        txId: string;
        paymentHash: string;
        sender: string;
      }
    >;

    PaymentFinalityProved(
      chainId?: null,
      ledger?: null,
      txId?: null,
      paymentHash?: null,
      sender?: null
    ): TypedEventFilter<
      [number, BigNumber, string, string, string],
      {
        chainId: number;
        ledger: BigNumber;
        txId: string;
        paymentHash: string;
        sender: string;
      }
    >;
  };

  estimateGas: {
    chains(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    commitRevealLowerBound(overrides?: CallOverrides): Promise<BigNumber>;

    commitRevealUpperBound(overrides?: CallOverrides): Promise<BigNumber>;

    dataAvailabilityPeriodsMined(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    disprovePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    finalisedDataAvailabilityPeriods(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    finalisedPayments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDataAvailabilityPeriodIndexFinality(
      chainId: BigNumberish,
      dataAvailabilityPeriodIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDataAvailabilityPeriodsMined(
      miner: string,
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLatestIndex(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPaymentFinality(
      chainId: BigNumberish,
      txId: BytesLike,
      destinationHash: BytesLike,
      amount: BigNumberish,
      currencyHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRewardPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalDataAvailabilityPeriodsMined(
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialiseChains(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialiseTime(overrides?: CallOverrides): Promise<BigNumber>;

    initialised(overrides?: CallOverrides): Promise<BigNumber>;

    numChains(overrides?: CallOverrides): Promise<BigNumber>;

    proposedDataAvailabilityProofs(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposedNonPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposedPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proveDataAvailabilityPeriodFinality(
      chainId: BigNumberish,
      ledger: BigNumberish,
      dataAvailabilityPeriodHash: BytesLike,
      chainTipHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    provePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rewardPeriodTimespan(overrides?: CallOverrides): Promise<BigNumber>;

    senderBannedUntil(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalDataAvailabilityPeriodsMined(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    chains(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    commitRevealLowerBound(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    commitRevealUpperBound(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    dataAvailabilityPeriodsMined(
      arg0: string,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    disprovePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    finalisedDataAvailabilityPeriods(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    finalisedPayments(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDataAvailabilityPeriodIndexFinality(
      chainId: BigNumberish,
      dataAvailabilityPeriodIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDataAvailabilityPeriodsMined(
      miner: string,
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLatestIndex(
      chainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPaymentFinality(
      chainId: BigNumberish,
      txId: BytesLike,
      destinationHash: BytesLike,
      amount: BigNumberish,
      currencyHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRewardPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTotalDataAvailabilityPeriodsMined(
      rewardSchedule: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialiseChains(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialiseTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initialised(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    numChains(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposedDataAvailabilityProofs(
      arg0: string,
      arg1: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proposedNonPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proposedPaymentProofs(
      arg0: BytesLike,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proveDataAvailabilityPeriodFinality(
      chainId: BigNumberish,
      ledger: BigNumberish,
      dataAvailabilityPeriodHash: BytesLike,
      chainTipHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    provePaymentFinality(
      chainId: BigNumberish,
      paymentHash: BytesLike,
      ledger: BigNumberish,
      txId: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rewardPeriodTimespan(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    senderBannedUntil(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalDataAvailabilityPeriodsMined(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
